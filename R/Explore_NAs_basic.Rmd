---
title: "Explore_NAs_basic"
author: "Jelena Meyer"
date: "2023-06-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# load packages
library(FFTrees)

# load replace_values function
replace_values <- function(data, cols, amount, replacement = NA, levels_amount = NULL) {


  # Verify inputs ----
  testthat::expect_true(is.data.frame(data), info = "Data should be a dataframe.") # check that data is a dataframe.
  testthat::expect_true(all(cols %in% names(data)), info = "All column names should be present in the data.") # check that columns is/are all variables in the dataframe.
  testthat::expect_true(length(cols) == length(amount), info = "Number of columns and percentages have to match.") # check if columns and percentages are of the same length.
  testthat::expect_true(all(is.numeric(amount) & (amount >= 0) ), info = "All amounts should be numeric values.") # check that percentages are all numbers between 0 and 1, or higher (than treat as number of to be replaced values.
  testthat::expect_true(is.character(replacement) | is.numeric(replacement) | is.logical(replacement) | is.na(replacement), info = "Replacement value should be of a valid data type (character, nummeric, logical or NA).") # check that replacement is a valid data type.
  testthat::expect_true(is.null(levels_amount) | is.list(levels_amount), info = "levels_amount should be a list") # check that levels_amount is a list if it's not NULL.
  if (!is.null(levels_amount)) {
    testthat::expect_true(all(names(levels_amount) %in% cols), info = "All names in levels_amount have to correspond to a column in the data.") # check if all elements in levels_amount correspond to a column in the data frame.
    for (col in names(levels_amount)) {
      if (is.factor(data[[col]])) {
        testthat::expect_true(all(names(levels_amount[[col]]) %in% levels(data[[col]])), info = "All levels in levels_amount have to be present in the corresponding column of the data.") # check if all sub-elements in each element are valid levels in the corresponding factor variable.

         }

      else if (is.character(data[[col]])) {
        testthat::expect_true(all(names(levels_amount[[col]]) %in% unique(data[[col]])), info = "All levels in levels_amount have to be present in the corresponding column of the data.")

         }

     }

  }


  # loop function over all columns that are inserted in form of a vector and corresponding percentages:
  for (i in seq_along(cols)) {

    col <- cols[i]
    perc <- amount[i]


    # Check if the specific column is a factor and has levels_amount defined:
    if (is.factor(data[[col]]) || is.character(data[[col]]) && !is.null(levels_amount) && col %in% names(levels_amount)) {

      # if all these conditions apply for the column, code is executed:
      # get list of different replacement percentages of levels in column:
      lev_amount <- levels_amount[[col]]

      # loop over levels in current column:
      for (cat in names(lev_amount)) {

        # get replacement percentage for current category:
        replace_perc <- lev_amount[[cat]]

        # get rows in column for current category:
        rows <- which(data[[col]] == cat)

        # Calculate how many values should be replaced in category:
        num_replace <-  ifelse(amount < 1, round(replace_perc * length(rows), 0), amount)


        # Use sample to replace specified percentage of category with replacement input:
        replace_rows <- sample(rows, size = num_replace [1],  replace = FALSE)
        data[replace_rows, col] <- replacement

      }

    } else {

      # Calculate how many values should be replaced:
      num_values <- nrow(data)
      num_replace <-  ifelse(amount < 1, round(amount * num_values, 0), amount)

      # Use sample to replace specified percentage with replacement input:
      replace_rows <- sample(1:num_values,  size = num_replace [1],  replace = FALSE)
      data[replace_rows, col] <- replacement

    }

  }

  # Output: ----

  return(data) # as data frame.

} # replace_values().

```



```{r Baseline}

#Build tree for normal data set


heart.fft <- FFTrees(formula = diagnosis ~.,
                     data = heart.train,
                     data.test = heart.train,
                     main = "Heart Disease",
                     decision.labels = c("Healthy", "Diseased"))

```


```{r add NAs in data sets}

# Preparations:

# get all names of variables but exclude criterion: 
column_names_heart<- colnames(heart.train)
column_names_heart <- column_names_heart[column_names_heart != 'diagnosis']

# in total 25%/50%/75% should be NAs in the end, split equally over all variables: 
num_columns<- length(column_names_heart)
pc_per_row_25<- 0.25
pc_per_row_50<- 0.5
pc_per_row_75<- 0.75

# create vector with that pc for number of rows:
pc_vector_25 <- rep(pc_per_row_25, times = num_columns)
pc_vector_50 <- rep(pc_per_row_50, times = num_columns)
pc_vector_75 <- rep(pc_per_row_75, times = num_columns)

# apply replace_values function and thereby create new data frames:

# set seed for being able to replicate results:
set.seed(13)

# 25% NAs in data set:
heart_NA_25 <- replace_values(data = heart.train, cols = column_names_heart, amount = pc_vector_25)
# 50% NAs in data set:
heart_NA_50 <- replace_values(data = heart.train, cols = column_names_heart, amount = pc_vector_50)
# 75% NAs in data set:
heart_NA_75 <- replace_values(data = heart.train, cols = column_names_heart, amount = pc_vector_75)


```

# Applying the FFTrees function to all manipulated data sets.

```{r new best trees, 25% NAs}

# build best tree. 25% NAs (standard function)
heart.fft_NA_25 <- FFTrees(formula = diagnosis ~.,
                     data = heart_NA_25,
                     main = "Heart Disease",
                     decision.labels = c("Healthy", "Diseased"))


# Report on NA cases: 
tree_level_outcome_vars <- c(1:3, 7:12, 25:30)
heart.fft_NA_25$trees$level_stats$train[ , tree_level_outcome_vars]
  
#plot(heart.fft_NA_25)


```


```{r new best trees, 50% NAs}

# build best tree, 50% NAs (standard function)
heart.fft_NA_50 <- FFTrees(formula = diagnosis ~.,
                     data = heart_NA_50,
                     main = "Heart Disease",
                     decision.labels = c("Healthy", "Diseased"))


# Report on NA cases: 
tree_level_outcome_vars <- c(1:3, 7:12, 25:30)
heart.fft_NA_50$trees$level_stats$train[ , tree_level_outcome_vars]
  

#plot(heart.fft_NA_50)



```


```{r new best trees, 75% NAs}
# build best tree, 75% NAs (standard function)
heart.fft_NA_75 <- FFTrees(formula = diagnosis ~.,
                     data = heart_NA_75,
                     main = "Heart Disease",
                     decision.labels = c("Healthy", "Diseased"))



# Report on NA cases: 
tree_level_outcome_vars <- c(1:3, 7:12, 25:30)
heart.fft_NA_75$trees$level_stats$train[ , tree_level_outcome_vars]
  
#plot(heart.fft_NA_75)


```





# No compensation
Besides investigating the performance of newly built trees, we are also interested in the trees performance using the tree that was the best when there was no missing data in the data set yet.
```{r Tree performance, not allowing for compensation, preparations}

# get definition of best train.tree:
def_best<- inwords(heart.fft, tree = 1)

# define for further using:
#def_best <-  "If thal = {rd,fd}, decide TRUE. If cp != {a}, decide FALSE.  If ca > 0, decide TRUE, otherwise, decide FALSE."
  


```


```{r Tree performance, not allowing for compensation, 25% NAs}

# Define trees with new data but old best tree: 

# data NA 25%
heart.fft_NA_25_oldbest <- FFTrees(formula = diagnosis ~.,
                     data = heart_NA_25,
                     my.tree = def_best,
                     main = "Heart Disease",
                     decision.labels = c("Healthy", "Diseased"))

#plot(heart.fft_NA_25_oldbest)


```


```{r Tree performance, not allowing for compensation, 50% NAs}

# build best tree, 50% NAs (standard function)
heart.fft_NA_50_oldbest <- FFTrees(formula = diagnosis ~.,
                     data = heart_NA_50,
                     my.tree = def_best,
                     main = "Heart Disease",
                     decision.labels = c("Healthy", "Diseased"))

#plot(heart.fft_NA_50_oldbest)


```


```{r Tree performance, not allowing for compensation, 75% NAs}

# build best tree, 75% NAs (standard function)
heart.fft_NA_75_oldbest <- FFTrees(formula = diagnosis ~.,
                     data = heart_NA_75,                     
                     my.tree = def_best,
                     main = "Heart Disease",
                     decision.labels = c("Healthy", "Diseased"))


#plot(heart.fft_NA_75_oldbest)

```

In all cases the performance of the trees was worse when not allowing for missing data versus when compensating was allowed.
